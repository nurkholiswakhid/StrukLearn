<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<resources>
    <string name="app_name">struklearn</string>
    <string name="loading">Loadingâ€¦</string>
    <string name="no_internet_connection">No internet connection!</string>
<string name="msg_contoh_penambah">Contoh Penambahan Node</string>
  <string name="lbl_penambahan_node">Penambahan Node</string>
  <string name="msg_heap_sort_meng">Heap Sort: Menggunakan sifat heap untuk mengurutkan elemen dalam array.</string>
  <string name="lbl_sedangkan">, sedangkan </string>
  <string name="lbl_heap">Heap</string>
  <string name="msg_pelajari_langka">Pelajari Langkah demi Langkah</string>
  <string name="msg_algoritma_dan_a">Algoritma dan Analisis Kompleksitas: Tree digunakan dalam berbagai algoritma dan pemecahan masalah kompleks.</string>
  <string name="msg_beberapa_operas">Beberapa operasi dasar pada pohon binari meliputi:</string>
  <string name="msg_adalah_anak_ana"> adalah anak-anak </string>
  <string name="msg_pohon_binari_k">Pohon Binari: Konsep dan Implementasi</string>
  <string name="msg_melanjutkan_tra">Melanjutkan traversal pada anak kanan secara rekursif.</string>
  <string name="msg_operasi_pada_tr">Operasi pada Tree</string>
  <string name="msg_operasi_dasar_p">Operasi Dasar pada Pohon Binari</string>
  <string name="msg_untuk_memahami">Untuk memahami lebih baik, mari lihat contoh visualisasi tree sederhana:</string>
  <string name="msg_traversal_pada">Traversal pada tree adalah proses penelusuran atau visitasi setiap node dalam tree sesuai dengan urutan tertentu. Proses ini penting untuk memproses atau mencari data dalam tree dengan cara yang terstruktur.</string>
  <string name="msg_operasi_penamb">Operasi: Penambahan, Penghapusan, dan Pencarian Node</string>
  <string name="msg_pencarian_cepat">Pencarian Cepat: Karena sifat-sifat BST, pencarian dapat dilakukan secara efisien dengan mengurangi jumlah node yang harus diperiksa.</string>
  <string name="msg_pohon_binari_ad">Pohon binari adalah struktur data tree di mana setiap node memiliki paling banyak dua anak, yang biasanya disebut sebagai anak kiri dan anak kanan. Pada pohon binari, setiap node memiliki hubungan hierarki dengan node di atasnya (parent) dan node-node di bawahnya (anak-anak).</string>
  <string name="msg_cocok_untuk_mer"> Cocok untuk merepresentasikan struktur hierarki seperti struktur file pada sistem operasi.</string>
  <string name="msg_setelah_mengunj">Setelah mengunjungi node, melakukan traversal pada anak kiri, kemudian anak kanan secara rekursif.</string>
  <string name="lbl_implementasi">Implementasi</string>
  <string name="msg_edge_koneksi_a">Edge: Koneksi antara dua node, menunjukkan hubungan hierarki. </string>
  <string name="msg_priority_queue">Priority Queue: Implementasi umum menggunakan heap, di mana elemen dengan nilai tertinggi (pada Max Heap) atau terendah (pada Min Heap) dapat diambil dengan prioritas tertinggi.</string>
  <string name="lbl_node">Node:</string>
  <string name="msg_penjumlahan_kum">Penjumlahan Kumulatif: Untuk mendapatkan penjumlahan kumulatif elemen dari indeks 1 hingga i, kita melakukan penjumlahan elemen Fenwick Tree dari indeks 1 hingga i.</string>
  <string name="msg_kunjungi_node_s">Kunjungi node saat ini.</string>
  <string name="msg_implementasi_po">Implementasi Pohon Binari</string>
  <string name="lbl_a">A</string>
  <string name="msg_mengunjungi_nod">Mengunjungi node saat pertama kali ditemui.</string>
  <string name="lbl_b">B</string>
  <string name="lbl_c">C</string>
  <string name="msg_preorder_traver">Preorder Traversal</string>
  <string name="msg_penjelasan_mel2">"Penjelasan: Melakukan traversal pada anak kiri 'D', lalu anak kanan 'D' yaitu 'E', mengunjungi node 'B', anak kiri dari 'B' yaitu 'C', dan akhirnya mengunjungi node 'A'."</string>
  <string name="lbl_d">D</string>
  <string name="lbl_e">E</string>
  <string name="msg_mengakses_setia">Mengakses Setiap Node: Menjamin bahwa setiap node di dalam tree dikunjungi.</string>
  <string name="msg_node_yang_tidak"> Node yang tidak memiliki anak (node paling bawah).</string>
  <string name="msg_koneksi_antara"> Koneksi antara dua node, menunjukkan hubungan hierarki. </string>
  <string name="msg_membangun_ekspr">Membangun Ekspresi atau Formula: Traversal sering digunakan dalam membangun ekspresi matematika atau formula.</string>
  <string name="msg_tree_traversal">Tree Traversal
Pada N-ary Tree</string>
  <string name="msg_karena_6_lebih">Karena 6 lebih kecil dari 8, pencarian dilanjutkan pada subtree kiri.</string>
  <string name="msg_operasi_pembaru">Operasi Pembaruan Nilai</string>
  <string name="msg_mulai_dari_root">Mulai dari root, masukkan node ke antrian.</string>
  <string name="msg_tujuan_traversa">Tujuan Traversal</string>
  <string name="msg_heap_digunakan">Heap digunakan dalam berbagai konteks, termasuk:</string>
  <string name="msg_pohon_binari_da2">Pohon binari dapat diimplementasikan menggunakan struktur data sederhana yang terdiri dari node-node. Setiap node memiliki data dan referensi ke anak kiri dan anak kanannya.</string>
  <string name="msg_penambahan_node">Penambahan Node: Menambahkan node baru ke pohon binari.</string>
  <string name="msg_tempat_di_mana">tempat di mana pengetahuan tentang struktur data menjadi lebih mudah dipahami dan dikuasai.</string>
  <string name="msg_contoh_implemen2">Contoh Implementasi</string>
  <string name="msg_operasi_pada_fe">Operasi Pada Fenwick Tree</string>
  <string name="msg_node_memiliki_d">Node memiliki dua anak. Dalam kasus ini, umumnya digunakan nilai terbesar dari subtree kiri sebagai pengganti.</string>
  <string name="msg_root_node_pali">Root: Node paling atas dalam tree, menjadi awal dari hierarki. </string>
  <string name="lbl_red_black_tree">Red-Black Tree</string>
  <string name="msg_penambahan_ins">Penambahan (Insertion): Menambahkan elemen baru ke heap dan memastikan sifat heap tetap terjaga.</string>
  <string name="msg_dengan_represen">Dengan representasi ini, kita dapat mengimplementasikan operasi-operasi dasar pada pohon binari seperti penambahan, traversal, pencarian, dan penghapusan node.</string>
  <string name="lbl_edge">Edge:</string>
  <string name="msg_fenwick_tree_j">Fenwick Tree, juga dikenal sebagai Binary Indexed Tree (BIT), adalah struktur data yang memungkinkan operasi penjumlahan kumulatif (prefix sum) pada sejumlah elemen array dalam rentang tertentu dengan efisiensi waktu O(log n), di mana n adalah panjang array.</string>
  <string name="msg_fenwicktree_3">FenwickTree[3] += 7&#13;
FenwickTree[4] += 7&#13;
FenwickTree[8] += 7&#13;</string>
  <string name="msg_pada_saat_menam">Pada saat menambahkan node, nilai yang lebih kecil dari node tertentu ditempatkan di subtree kiri, dan nilai yang lebih besar ditempatkan di subtree kanan.</string>
  <string name="msg_node_tersebut_a">Node tersebut adalah daun (tidak memiliki anak).</string>
  <string name="msg_fenwick_tree_b">Fenwick Tree (Binary Indexed Tree)</string>
  <string name="msg_definisi_level">Definisi: Level-order Traversal mengunjungi node pada level yang sama sebelum melanjutkan ke level berikutnya.</string>
  <string name="msg_tree_digunakan">Tree digunakan dalam berbagai algoritma dan pemecahan masalah kompleks.</string>
  <string name="msg_contoh_implemen">Contoh Implementasi Sederhana</string>
  <string name="msg_pemrosesan_hier">Pemrosesan Hierarki: Cocok untuk merepresentasikan struktur hierarki seperti struktur file pada sistem operasi.</string>
  <string name="msg_algoritma_dijks">Algoritma Dijkstra dan Prim: Menggunakan heap untuk memilih dan memperbarui node dengan prioritas tertinggi.</string>
  <string name="msg_membangun_fenwi">Membangun Fenwick Tree: Pembangunan dilakukan dengan melakukan penjumlahan kumulatif pada setiap elemen array ke elemen Fenwick Tree yang sesuai.</string>
  <string name="msg_melakukan_trave">Melakukan traversal pada anak kiri.</string>
  <string name="msg_melakukan_trave2">Melakukan traversal pada anak kanan.</string>
  <string name="lbl_leaf">Leaf:</string>
  <string name="msg_gunakan_antrian">Gunakan antrian (queue) untuk melacak urutan pengunjungan.</string>
  <string name="msg_heap_implement">Heap: Implementasi dan Penggunaan</string>
  <string name="msg_definisi_traver">Definisi Traversal</string>
  <string name="msg_contoh_pengguna">Contoh Penggunaan</string>
  <string name="lbl_get_started">GET STARTED</string>
  <string name="msg_penghapusan_nod4">Penghapusan Node Umum</string>
  <string name="msg_penghapusan_nod5">Penghapusan node melibatkan beberapa skenario, termasuk:</string>
  <string name="msg_penghapusan_nod2">Penghapusan Node</string>
  <string name="msg_penghapusan_nod3">Penghapusan Node pada Tree</string>
  <string name="msg_misalkan_kita_m2">Misalkan kita memiliki array sebagai berikut:</string>
  <string name="msg_misalkan_kita_m">Misalkan kita memiliki pohon binari sebagai berikut:</string>
  <string name="msg_jika_nilai_node">Jika nilai node saat ini sama dengan nilai yang dicari, maka node tersebut ditemukan.</string>
  <string name="msg_misalkan_kita_i">Misalkan kita ingin menambahkan node dengan nilai 9 pada pohon berikut:</string>
  <string name="msg_postorder_trave">Postorder Traversal</string>
  <string name="msg_output_d_e_b">Output: D, E, B, C, A</string>
  <string name="msg_penjumlahan_kum2">Penjumlahan Kumulatif: FenwickTree[5] - FenwickTree[0] = 11&#13;</string>
  <string name="msg_pencarian_dilak">Pencarian dilakukan dengan membandingkan nilai yang dicari dengan nilai node saat ini.</string>
  <string name="msg_lakukan_travers">Lakukan traversal pada setiap anak dari kiri ke kanan secara rekursif.</string>
  <string name="msg_pemrosesan_data">Pemrosesan Data: Melakukan operasi atau pemrosesan pada data setiap node.</string>
  <string name="msg_operasi_pada_bs">Operasi pada BST</string>
  <string name="msg_pencarian_node2">Pencarian Node pada Tree</string>
  <string name="msg_tree_traversal2">Tree Traversal pada N-ary Tree</string>
  <string name="msg_pengenalan_stru">Pengenalan struktur Data Tree</string>
  <string name="msg_dalam_pemilihan">Dalam pemilihan antara AVL dan Red-Black Tree, keputusan bergantung pada kebutuhan aplikasi spesifik. Jika operasi pencarian lebih dominan, AVL Tree mungkin lebih cocok, sementara jika penambahan atau penghapusan sering terjadi, Red-Black Tree dapat memberikan keseimbangan yang memadai dengan kinerja yang lebih baik.</string>
  <string name="msg_sifat_rekursif">Sifat Rekursif: Subtree kiri dan subtree kanan dari setiap node juga merupakan BST.</string>
  <string name="msg_algoritma_dan_a2">Algoritma dan Analisis Kompleksitas: </string>
  <string name="msg_penghapusan_nod">Penghapusan Node: Menghapus node tertentu dari pohon binari.</string>
  <string name="msg_node_dengan_nil">Node dengan nilai 10 memiliki dua anak, sehingga kita mencari nilai terbesar di subtree kiri (nilai 9) untuk menggantikan nilainya.</string>
  <string name="msg_manajemen_memor">Manajemen Memori Dinamis: Heap digunakan untuk alokasi dan dealokasi memori dalam beberapa sistem.</string>
  <string name="msg_membangun_fenwi2">Membangun Fenwick Tree</string>
  <string name="msg_node_dengan_nil2">Node dengan nilai 9 kemudian dihapus.</string>
  <string name="msg_selamat_datang">Selamat datang di StrukLearn !</string>
  <string name="msg_level_order_tra">Level-order Traversal</string>
  <string name="msg_node_dengan_dua">Node dengan Dua Anak: Nilai node digantikan oleh nilai node terbesar dari subtree kiri atau nilai node terkecil dari subtree kanan.</string>
  <string name="msg_output_a_b_d">Output: A, B, D, E, C</string>
  <string name="msg_ada_tiga_skenar">Ada tiga skenario saat menghapus node:</string>
  <string name="msg_lanjutkan_trave">Lanjutkan traversal pada setiap anak dari kiri ke kanan secara rekursif.</string>
  <string name="msg_fenwick_tree">Fenwick Tree: [1, 3, 3, 10, 5, 11, 7, 36]</string>
  <string name="msg_pencarian_efisi">Pencarian Efisien: Tree memungkinkan pencarian data dengan cepat karena setiap langkah dapat mempersempit ruang pencarian.</string>
  <string name="msg_jika_tidak_kit">Jika tidak, kita perlu membandingkan nilai node baru dengan nilai node saat ini dan menentukan apakah node baru harus ditempatkan di subtree kiri atau subtree kanan.</string>
  <string name="msg_kita_bandingkan">Kita bandingkan 9 dengan nilai root (8). Karena 9 lebih besar dari 8, kita pergi ke subtree kanan. Selanjutnya, kita bandingkan 9 dengan 10. Karena 9 lebih kecil dari 10, kita pergi ke subtree kiri. Namun, subtree kiri dari 10 kosong, sehingga 9 dapat ditempatkan di situ.</string>
  <string name="msg_contoh_penghapu">Contoh Penghapusan Node</string>
  <string name="msg_operasi_penjuml">Operasi Penjumlahan Kumulatif
Untuk mendapatkan penjumlahan kumulatif dari indeks 1 hingga 5:</string>
  <string name="msg_binary_search_t3">Binary Search Tree (BST) adalah struktur data tree yang memenuhi sifat-sifat tertentu yang mempermudah pencarian, penambahan, dan penghapusan data. Setiap node dalam BST memiliki dua anak (kiri dan kanan) yang memungkinkan pengurutan data dengan cepat.</string>
  <string name="msg_binary_search_t2">Binary Search Tree (BST)</string>
  <string name="lbl_keuntungan_bst">Keuntungan BST</string>
  <string name="lbl_root">Root: </string>
  <string name="msg_inorder_travers">Inorder Traversal</string>
  <string name="msg_node_dengan_sat">Node dengan Satu Anak: Node dihapus, dan anaknya menggantikan posisinya.</string>
  <string name="lbl_pencarian_node">Pencarian Node</string>
  <string name="lbl_sifat_sifat_bst">Sifat-sifat BST</string>
  <string name="msg_avl_tree_adalah">AVL Tree adalah pohon binari pencarian yang memastikan keseimbangan dengan menjaga faktor keseimbangan setiap node, yaitu selisih antara tinggi subtree kanan dan kiri. Jika faktor keseimbangan suatu node di luar rentang -1 hingga 1, rotasi dilakukan untuk memulihkan keseimbangan. Meskipun AVL Tree memberikan keseimbangan yang ketat, operasi seperti penambahan dan penghapusan mungkin lebih lambat dibandingkan Red-Black Tree.</string>
  <string name="msg_dalam_contoh_di2">Dalam contoh di samping </string>
  <string name="msg_struktur_data_p">Struktur Data Pohon Binari</string>
  <string name="msg_membangun_heap">Membangun Heap (Heapify): Mengubah array tidak terurut menjadi heap.</string>
  <string name="msg_struktur_data_t">STRUKTUR DATA TREE</string>
  <string name="msg_representasi_da">Representasi dalam Array: Fenwick Tree direpresentasikan dalam bentuk array. Setiap elemen tree menyimpan jumlah elemen dalam beberapa bagian dari array. Bit terendah (LSB) dari indeks digunakan untuk menentukan batas rentang yang diwakili oleh elemen itu.</string>
  <string name="msg_jika_kita_mempe">Jika kita memperbarui nilai elemen array pada indeks 3 menjadi 10, kita juga memperbarui Fenwick Tree:</string>
  <string name="msg_misalkan_kita_i2">Misalkan kita ingin menghapus node dengan nilai 10 pada pohon di atas. Prosesnya sebagai berikut:</string>
  <string name="msg_misalkan_kita_i3">Misalkan kita ingin mencari node dengan nilai 6 pada pohon di atas. Prosesnya sebagai berikut:</string>
  <string name="msg_karena_6_lebih2">Karena 6 lebih besar dari 3, pencarian dilanjutkan pada subtree kanan.</string>
  <string name="msg_penambahan_node2">Penambahan Node pada Tree</string>
  <string name="msg_penambahan_node3">Penambahan Node Umum</string>
  <string name="msg_berikut_adalah">Berikut adalah representasi Fenwick Tree setelah pembangunan:</string>
  <string name="msg_contoh_visualis">Contoh Visualisasi Tree</string>
  <string name="msg_heap_adalah_str">Heap adalah struktur data pohon binari yang digunakan untuk operasi penambahan dan ekstraksi elemen dengan prioritas tertentu. Implementasi heap biasanya menggunakan array, di mana elemen diindeks i memiliki dua anak pada indeks 2i+1 dan 2i+2.</string>
  <string name="msg_perbedaan_utama">Perbedaan utama antara keduanya adalah dalam pendekatan menjaga keseimbangan. AVL Tree memiliki pendekatan yang lebih ketat dengan memantau faktor keseimbangan, sementara Red-Black Tree lebih fleksibel dengan fokus pada jumlah node hitam dalam jalur tertentu. Red-Black Tree sering dipilih dalam implementasi struktur data seperti set dan peta karena dapat memberikan keseimbangan yang baik dengan performa operasional yang baik.</string>
  <string name="lbl_tree_balance">Tree Balance</string>
  <string name="msg_nilai_6_dibandi2">Nilai 6 dibandingkan dengan nilai node saat ini (3).</string>
  <string name="msg_merupakan_salah"> merupakan salah satu bentuk struktur data yang digunakan untuk merepresentasikan hubungan hierarki antara elemen-elemen data. Dalam tree, data disusun dalam bentuk node, yang terhubung oleh edge. Setiap tree memiliki satu node khusus yang disebut root, dan setiap node memiliki node-nodes anak yang terhubung melalui edge.</string>
  <string name="msg_mengunjungi_nod2">Mengunjungi node saat kedua kalinya ditemui.</string>
  <string name="msg_heap_dapat_diim">Heap dapat diimplementasikan dengan menggunakan array dan memanfaatkan sifat bahwa elemen teratas (root) memiliki nilai tertinggi (Max Heap) atau terendah (Min Heap) di antara semua elemen.</string>
  <string name="lbl_penggunaan">Penggunaan</string>
  <string name="msg_pengurutan_otom">Pengurutan Otomatis: Data di BST selalu terurut, memudahkan penggunaan algoritma pengurutan.</string>
  <string name="msg_representasi_el"> Representasi elemen data dalam tree. </string>
  <string name="msg_traversal_tree">Traversal Tree: Preorder, Inorder, dan Postorder</string>
  <string name="msg_mengunjungi_nod3">Mengunjungi node saat ketiga kalinya ditemui.</string>
  <string name="msg_red_black_tree">Red-Black Tree juga merupakan pohon binari pencarian yang mempertahankan keseimbangan dengan memperkenalkan atribut warna pada setiap node. Properti utama Red-Black Tree adalah bahwa setiap jalur dari root hingga leaf harus memiliki jumlah node hitam yang sama. Rotasi dan perubahan warna dilakukan saat penambahan atau penghapusan untuk memastikan properti tersebut terpenuhi. Kelebihan Red-Black Tree terletak pada fleksibilitasnya, yang memungkinkan operasi penambahan dan penghapusan lebih cepat daripada AVL Tree.</string>
  <string name="msg_binary_search_t">Binary Search
Tree</string>
  <string name="lbl_avl_tree">AVL Tree</string>
  <string name="msg_penjelasan_mel">"Penjelasan: Melakukan traversal pada anak kiri, yaitu 'D', lalu mengunjungi node 'B', anak kanan dari 'B' yaitu 'E', kemudian mengunjungi node 'A', dan akhirnya mengunjungi node 'C'."</string>
  <string name="msg_penjelasan_men">"Penjelasan: Mengunjungi node 'A' terlebih dahulu, lalu anak kiri 'B', anak kiri dari 'B' yaitu 'D', anak kanan dari 'B' yaitu 'E', dan akhirnya anak kanan dari 'A' yaitu 'C'."</string>
  <string name="msg_node_represent">Node: Representasi elemen data dalam tree. </string>
  <string name="msg_node_paling_ata">Node paling atas dalam tree, menjadi awal dari hierarki. </string>
  <string name="msg_untuk_menambahk">Untuk menambahkan node pada tree, kita harus memahami struktur tree dan memutuskan tempat yang tepat untuk menempatkan node baru.</string>
  <string name="msg_dalam_contoh_di">Dalam contoh di samping A adalah root, B dan C adalah anak-anak A, sedangkan D dan E adalah anak-anak B. Setiap node membentuk struktur yang mirip pohon, sehingga istilah "tree" digunakan.</string>
  <string name="msg_tree_balance_a">Tree Balance: AVL dan Red-Black Tree</string>
  <string name="lbl_traversal_tree">Traversal Tree</string>
  <string name="msg_prinsip_pencari">Prinsip Pencarian</string>
  <string name="msg_array_1_2_3">Array: [1, 2, 3, 4, 5, 6, 7, 8]&#13;</string>
  <string name="lbl_pohon_binari">Pohon Binari</string>
  <string name="msg_definisi_binary">Definisi Binary Search Tree (BST)</string>
  <string name="msg_pembaruan_nilai">Pembaruan Nilai: Untuk memperbarui nilai elemen array pada indeks i, kita juga memperbarui elemen Fenwick Tree yang sesuai.</string>
  <string name="lbl_perbandingan">Perbandingan</string>
  <string name="msg_pengenalan_data">Pengenalan
Data Tree</string>
  <string name="msg_struktur_data_t4">Struktur data tree digunakan untuk merepresentasikan hubungan hierarki secara efisien. Beberapa tujuan penggunaan tree meliputi:</string>
  <string name="msg_contoh_pencaria">Contoh Pencarian Node</string>
  <string name="msg_struktur_data_t2">Struktur Data Tree merupakan salah satu bentuk struktur data yang digunakan untuk merepresentasikan hubungan hierarki antara elemen-elemen data. Dalam tree, data disusun dalam bentuk node, yang terhubung oleh edge. Setiap tree memiliki satu node khusus yang disebut root, dan setiap node memiliki node-nodes anak yang terhubung melalui edge.</string>
  <string name="msg_struktur_data_t3">Struktur Data Tree</string>
  <string name="msg_ekstraksi_extr">Ekstraksi (Extraction): Mengambil elemen teratas dari heap (root) dan memastikan sifat heap tetap terjaga.</string>
  <string name="msg_traversal_pada2">Traversal pada N-ary Tree adalah teknik untuk mengunjungi setiap node dalam struktur pohon N-ary. Pohon N-ary adalah pohon di mana setiap node dapat memiliki lebih dari dua anak. Traversal membantu kita menjelajahi dan memproses setiap elemen dalam pohon. Terdapat beberapa metode utama untuk melakukan traversal pada N-ary Tree.</string>
  <string name="msg_operasi_pada_he">Operasi Pada Heap</string>
  <string name="msg_node_daun_node">Node Daun: Node yang tidak memiliki anak. Penghapusan dapat dilakukan langsung.</string>
  <string name="msg_selama_antrian">Selama antrian tidak kosong, ambil node dari antrian, kunjungi, dan masukkan semua anaknya ke antrian.</string>
  <string name="msg_traversal_pohon">Traversal Pohon: Melakukan penelusuran atau visitasi pada setiap node, seperti pre-order, in-order, dan post-order.</string>
  <string name="lbl_adalah_root"> adalah root, </string>
  <string name="lbl_fenwick_tree">Fenwick Tree</string>
  <string name="msg_kunjungi_node_s2">Kunjungi node saat ini saat ketiga kalinya.</string>
  <string name="msg_pohon_binari_da">Pohon binari dapat direpresentasikan secara visual dengan menggunakan grafik yang menunjukkan hubungan hierarki antar node. Contoh representasi visual pohon binari:</string>
  <string name="msg_jika_tree_masih">Jika tree masih kosong, node baru dapat langsung menjadi root.</string>
  <string name="msg_definisi_posto">Definisi: Postorder Traversal mengunjungi node saat ketiga kalinya ditemui.</string>
  <string name="msg_pemrosesan_hier2">Pemrosesan Hierarki:</string>
  <string name="msg_nilai_node_10_d">Nilai node 10 diganti dengan nilai 9.</string>
  <string name="msg_sifat_pencarian">Sifat Pencarian: Untuk setiap node dalam BST, nilai semua node anak di sebelah kiri harus lebih kecil, dan nilai semua node anak di sebelah kanan harus lebih besar.</string>
  <string name="msg_definisi_dan_ko">Definisi dan Konsep Dasar</string>
  <string name="msg_langkah_langkah">Langkah-langkah:</string>
  <string name="msg_tujuan_pengguna">Tujuan Penggunaan Tree</string>
  <string name="msg_setiap_node_m">. Setiap node membentuk struktur yang mirip pohon, sehingga istilah "tree" digunakan.</string>
  <string name="msg_penghapusan_dan">Penghapusan dan Penambahan Efisien: Jika sifat BST tetap terjaga, operasi penghapusan dan penambahan dapat dilakukan dengan efisien.</string>
  <string name="msg_nilai_6_ditemuk">Nilai 6 ditemukan pada node dengan nilai 6.</string>
  <string name="lbl_quiz">QUIZ</string>
  <string name="msg_metode_traversa">Metode Traversal</string>
  <string name="msg_perubahan_nilai">Perubahan Nilai (Decrease atau Increase Key): Mengubah nilai elemen tertentu dalam heap dan memastikan sifat heap tetap terjaga.</string>
  <string name="msg_konsep_pohon_bi">Konsep Pohon Binari</string>
  <string name="lbl_dan"> dan </string>
  <string name="msg_pencarian_node">Pencarian Node: Mencari keberadaan suatu node dalam pohon binari.</string>
  <string name="msg_definisi_preor">Definisi: Preorder Traversal mengunjungi node saat pertama kali ditemui.</string>
  <string name="msg_leaf_node_yang">Leaf: Node yang tidak memiliki anak (node paling bawah).</string>
  <string name="msg_nilai_6_dibandi">Nilai 6 dibandingkan dengan nilai root (8).</string>
  <string name="msg_output_d_b_e">Output: D, B, E, A, C</string>
  <string name="msg_jika_nilai_yang">Jika nilai yang dicari lebih kecil, pencarian dilanjutkan pada subtree kiri; jika lebih besar, dilanjutkan pada subtree kanan.</string>
  <string name="_2">2.</string>
  <string name="_1">1.</string>
  <string name="_3">3.</string>
  <string name="node_memiliki_satu_anak">Node memiliki satu anak.</string>
</resources>
